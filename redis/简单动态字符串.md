### 简单动态字符串（SDS）

#### **C语言字符串**

使用长度为N+1的字符数组来标识长度为N的字符串，并且字符数组的最后一个元素总是空字符 '\0'

在Redis里并没有直接使用C语言的字符串标识，而是自己构建了一种名为**简单动态字符串（SDS）**的抽象类型，并将SDS作为Redis的默认字符串表示

#### SDS的定义

```shell
struct sdshdr {
	// 记录buf数组中已经使用的字节数量
	// 等于SDS所保存字符串的长度
	int	len;
	
	// 记录buf数组中未使用字节的数量
	int free;
	
	// 字节数组，用于保护字符串
	char buf[];
}
```

图1展示了一个 SDS 示例：

<img src="/Users/chunbo/daydayup/Redis/简单动态字符串.assets/1.png" alt="1" style="zoom:50%;" />

​																						**图1**

- free属性的值为0，表示这个SDS没有分配未使用的空间。
- len属性的值为5，表示这个SDS保存了一个5个字节长度的字符串。
- buf属性是一个char类型的数组，数组的前5个字节分别存了`'R'` 、 `'e'` 、 `'d'` 、 `'i'` 、 `'s'` 五个字符，而最后一个字节保存了空字符 `'\0'`。

注：SDS遵循C字符串一空字符结尾的特性，保存空字符的一字节空间不计算在SDS的len属性里面，并且为空字节分配额外的1字节空间。

#### SDS与C字符串的区别

##### 常数复杂度获取字符串长度

因为C字符串并不记录自身长度，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对每个字符串进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为 O(N) 。

和 C 字符串不同， 因为 SDS 在 `len` 属性中记录了 SDS 本身的长度，程序只要访问 SDS 的 `len` 属性， 就可以立即知道 SDS 的长度，所以获取一个 SDS 长度的复杂度仅为 O(1) 。

通过使用 SDS 而不是 C 字符串， Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1) ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈。

##### 杜绝缓冲区溢出

除了获取字符串长度的复杂度高之外， C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。

举个例子， `<string.h>/strcat` 函数可以将 `src` 字符串中的内容拼接到 `dest` 字符串的末尾：

```shell
char *strcat(char *dest, const char *src);
```

因为 C 字符串不记录自身的长度， 所以 `strcat` 假定用户在执行这个函数时， 已经为 `dest` 分配了足够多的内存， 可以容纳 `src` 字符串中的所有内容， 而一旦这个假定不成立时， 就会产生缓冲区溢出。

举个例子， 假设程序里有两个在内存中紧邻着的 C 字符串 `s1` 和 `s2` ， 其中 `s1` 保存了字符串 `"Redis"` ， 而 `s2` 则保存了字符串 `"MongoDB"` ， 如图2所示。

<img src="/Users/chunbo/daydayup/Redis/简单动态字符串.assets/image-20220309225745524.png" alt="image-20220309225745524" style="zoom:50%;" />



​																					**图2**

如果一个程序员决定通过执行`strcat(s1, " Cluster")`将 `s1` 的内容修改为 `"Redis Cluster"`,但粗心的他却忘了在执行 `strcat` 之前为 `s1` 分配足够的空间， 那么在 `strcat` 函数执行之后， `s1` 的数据将溢出到 `s2` 所在的空间中， 导致 `s2` 保存的内容被意外地修改(`MongoDB` ->`Cluster` )，如图3

<img src="/Users/chunbo/daydayup/Redis/简单动态字符串.assets/image-20220309230058737.png" alt="image-20220309230058737" style="zoom:50%;" />

​																					**图3**

与 C 字符串不同， SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性： 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。

##### 减少修改字符串时带来的内存重分配次数

因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：

- 如果程序执行的是增长字符串的操作， 比如拼接操作（append）， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。
- 如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。

因为内存重分配涉及复杂的算法， 并且可能需要执行系统调用， 所以它通常是一个比较耗时的操作：

- 在一般程序中， 如果修改字符串长度的情况不太常出现， 那么每次修改都执行一次内存重分配是可以接受的。
- 但是 Redis 作为数据库， 经常被用于速度要求严苛、数据被频繁修改的场合， 如果每次修改字符串的长度都需要执行一次内存重分配的话， 那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分， 如果这种修改频繁地发生的话， 可能还会对性能造成影响。

###### 空间预分配

​	空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。

其中， 额外分配的未使用空间数量由以下公式决定：

- 如果对 SDS 进行修改之后， SDS 的长度（也即是 `len` 属性的值）将小于 `1 MB` ， 那么程序分配和 `len` 属性同样大小的未使用空间， 这时 SDS `len` 属性的值将和 `free` 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 `len` 将变成 `13` 字节， 那么程序也会分配 `13` 字节的未使用空间， SDS 的 `buf` 数组的实际长度将变成 `13 + 13 + 1 = 27` 字节（额外的一字节用于保存空字符）。

- 如果对 SDS 进行修改之后， SDS 的长度将大于等于 `1 MB` ， 那么程序会分配 `1 MB` 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 `len` 将变成 `30 MB` ， 那么程序会分配 `1 MB` 的未使用空间， SDS 的 `buf` 数组的实际长度将为 `30 MB + 1 MB + 1 byte` 。

通过空间预分配策略， Redis 可以减少连续执行字符串增长操作所需的内存重分配次数。在扩展 SDS 空间之前， SDS API 会先检查未使用空间是否足够， 如果足够的话， API 就会直接使用未使用空间， 而无须执行内存重分配。

###### 惰性空间释放

惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 `free` 属性将这些字节的数量记录起来， 并等待将来使用。

通过惰性空间释放策略， SDS 避免了缩短字符串时所需的内存重分配操作， 并为将来可能有的增长操作提供了优化。

##### 二进制安全

C 字符串中的字符必须符合某种编码（比如 ASCII）， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。

举个例子， 如果有一种使用空字符来分割多个单词的特殊数据格式， 如图 4 所示， 那么这种格式就不能使用 C 字符串来保存， 因为 C 字符串所用的函数只会识别出其中的 `"Redis"` ， 而忽略之后的 `"Cluster"` 。

<img src="/Users/chunbo/daydayup/Redis/简单动态字符串.assets/image-20220309231449670.png" alt="image-20220309231449670" style="zoom:50%;" />

​																						**图4**

SDS 的 API 都是二进制安全的（binary-safe）： 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 `buf` 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。

这也是我们将 SDS 的 `buf` 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据。

##### 兼容部分C字符串函数

虽然 SDS 的 API 都是二进制安全的， 但它们一样遵循 C 字符串以空字符结尾的惯例： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 `buf` 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 `<string.h>` （C字符串函数库）库定义的函数。